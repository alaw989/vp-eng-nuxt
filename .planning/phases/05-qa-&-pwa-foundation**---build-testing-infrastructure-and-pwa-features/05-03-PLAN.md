---
phase: 05-qa-&-pwa-foundation
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified: [package.json, .husky/pre-commit, scripts/pre-commit.js]
autonomous: true

must_haves:
  truths:
    - "Pre-commit git hook runs build + preview before allowing commits"
    - "Hydration errors fail the commit (zero tolerance)"
    - "Pre-commit hook can be bypassed with --no-verify for emergency commits"
    - "Husky is initialized and hooks are committed to repository"
  artifacts:
    - path: "package.json"
      provides: "Husky dependency and prepare script"
      contains: "husky"
    - path: ".husky/pre-commit"
      provides: "Git pre-commit hook"
      contains: "pre-commit.js"
    - path: "scripts/pre-commit.js"
      provides: "Pre-commit validation script"
      contains: "build, preview"
  key_links:
    - from: ".husky/pre-commit"
      to: "scripts/pre-commit.js"
      via: "node script invocation"
      pattern: "node.*pre-commit"
    - from: "scripts/pre-commit.js"
      to: "npm run build"
      via: "execSync"
      pattern: "build"
    - from: "scripts/pre-commit.js"
      to: "npm run preview"
      via: "execSync"
      pattern: "preview"
---

<objective>
Establish build & preview testing workflow with pre-commit git hooks using Husky. All changes must be tested with production build before deployment.

Purpose: Development environment can mask production issues. Build testing catches hydration errors early. Per Phase 5 Context, pre-commit enforcement with full CI pipeline (build + preview + Lighthouse) is required.

Output: Husky initialized, pre-commit hook created, build + preview testing script, bypass mechanism documented.
</objective>

<execution_context>
@/home/deck/.claude/get-shit-done/workflows/execute-plan.md
@/home/deck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-qa-&-pwa-foundation**---build-testing-infrastructure-and-pwa-features/05-CONTEXT.md
@.planning/phases/05-qa-&-pwa-foundation**---build-testing-infrastructure-and-pwa-features/05-RESEARCH.md
@.planning/phases/05-qa-&-pwa-foundation**---build-testing-infrastructure-and-pwa-features/05-01-SUMMARY.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Install Husky and initialize git hooks</name>
  <files>package.json, .husky/pre-commit, .gitignore</files>
  <action>
    Install Husky for git hooks management:

    1. Install Husky as dev dependency:
       npm install -D husky

    2. Initialize Husky (creates .husky/ directory and sets up git hooks):
       npx husky init

    This will:
    - Add "prepare": "husky" to package.json scripts
    - Create .husky/ directory
    - Create .husky/pre-commit example file
    - Configure git to use .husky/ hooks

    3. Verify .husky/ directory was created
    4. Check that package.json has "prepare": "husky" in scripts

    Note: If .planning is gitignored, Husky still works fine. The hooks are in .husky/ which should not be gitignored.
  </action>
  <verify>
    - package.json contains "husky" in devDependencies
    - package.json contains "prepare": "husky" in scripts
    - .husky/ directory exists
    - .husky/pre-commit file exists (may have default content)
  </verify>
  <done>
    Husky is installed and initialized. Git hooks are configured to use .husky/ directory.
  </done>
</task>

<task type="auto">
  <name>Create scripts directory and pre-commit validation script</name>
  <files>scripts/pre-commit.js</files>
  <action>
    Create the scripts directory and pre-commit validation script:

    1. Create scripts directory if it doesn't exist:
       mkdir -p scripts

    2. Create scripts/pre-commit.js with the following content:

    ```javascript
    #!/usr/bin/env node

    import { execSync } from 'child_process';
    import { spawn } from 'child_process';
    import { fileURLToPath } from 'url';
    import { dirname, join } from 'path';
    import fs from 'fs';

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);

    // Configuration
    const PREVIEW_URL = 'http://localhost:3000';
    const PREVIEW_STARTUP_MS = 5000;
    const ENABLED_ENV_VAR = 'PRE_COMMIT_CHECKS_ENABLED';

    // Allow disabling via environment variable
    if (process.env[ENABLED_ENV_VAR] === 'false') {
      console.log('Pre-commit checks disabled via environment variable.');
      process.exit(0);
    }

    console.log('Running pre-commit validation...\n');

    let previewProcess = null;

    try {
      // Step 1: Build
      console.log('Step 1/4: Building...');
      const buildOutput = execSync('npm run build', {
        stdio: 'pipe',
        encoding: 'utf-8'
      });

      // Check for hydration errors in build output
      if (buildOutput.includes('[Vue warning]') || buildOutput.includes('Hydration mismatch')) {
        console.error('\nHydration errors detected in build output!');
        console.error('Hydration errors indicate server/client HTML mismatch.');
        console.error('Please fix these errors before committing.\n');
        console.error(buildOutput);
        process.exit(1);
      }

      console.log('Build successful.');

      // Step 2: Start preview server in background
      console.log('\nStep 2/4: Starting preview server...');

      previewProcess = spawn('npm', ['run', 'preview'], {
        stdio: 'pipe',
        detached: true,
        shell: true
      });

      // Wait for server to start
      console.log(`Waiting ${PREVIEW_STARTUP_MS}ms for server startup...`);
      await new Promise(resolve => setTimeout(resolve, PREVIEW_STARTUP_MS));

      // Check if server is running
      if (!previewProcess.pid) {
        throw new Error('Failed to start preview server');
      }

      console.log('Preview server started.');

      // Step 3: Check for hydration errors by making a request
      console.log('\nStep 3/4: Checking for hydration issues...');

      try {
        const response = await fetch(`${PREVIEW_URL}/`);
        const html = await response.text();

        // Basic check that page rendered (has main content)
        if (!html.includes('main') && !html.includes('Main')) {
          console.warn('Warning: Page may not have main content.');
        }
      } catch (fetchError) {
        console.warn(`Warning: Could not verify page load: ${fetchError.message}`);
      }

      console.log('No critical hydration issues detected.');

      // Step 4: Cleanup (kill preview server)
      console.log('\nStep 4/4: Cleaning up...');

      // Kill the process group
      if (process.platform === 'win32') {
        execSync(`taskkill /F /T /PID ${previewProcess.pid}`, { stdio: 'ignore' });
      } else {
        process.kill(-previewProcess.pid, 'SIGTERM');
      }

      await new Promise(resolve => setTimeout(resolve, 500));

      console.log('\nPre-commit checks passed!');
      process.exit(0);

    } catch (error) {
      // Cleanup on error
      if (previewProcess && previewProcess.pid) {
        try {
          if (process.platform === 'win32') {
            execSync(`taskkill /F /T /PID ${previewProcess.pid}`, { stdio: 'ignore' });
          } else {
            process.kill(-previewProcess.pid, 'SIGTERM');
          }
        } catch (killError) {
          // Ignore cleanup errors
        }
      }

      console.error('\nPre-commit validation failed:');
      console.error(error.message);

      // Show bypass instructions
      console.error('\nTo bypass this check, use:');
      console.error('  git commit --no-verify -m "your message"');
      console.error('Or disable temporarily:');
      console.error(`  ${ENABLED_ENV_VAR}=false git commit -m "your message"`);

      process.exit(1);
    }
    ```

    3. Make the script executable:
       chmod +x scripts/pre-commit.js

    Note: This script runs build + preview. Lighthouse will be added in plan 05-04.
  </action>
  <verify>
    - scripts/ directory exists
    - scripts/pre-commit.js exists and is executable
    - Script contains build, preview startup, and cleanup logic
    - Script checks for hydration errors in build output
  </verify>
  <done>
    Pre-commit validation script created with build + preview testing and hydration error detection.
  </done>
</task>

<task type="auto">
  <name>Configure Husky pre-commit hook</name>
  <files>.husky/pre-commit</files>
  <action>
    Replace the default .husky/pre-commit file with our pre-commit script:

    1. Read the existing .husky/pre-commit (if any)
    2. Replace with:

    ```bash
    #!/usr/bin/env sh
    . "$(dirname -- "$0")/_/husky.sh"

    echo "Running pre-commit checks..."
    node scripts/pre-commit.js
    ```

    3. Make the hook executable:
       chmod +x .husky/pre-commit

    The hook will run our pre-commit.js script before every commit.
  </action>
  <verify>
    - .husky/pre-commit exists and is executable
    - .husky/pre-commit calls node scripts/pre-commit.js
    - .husky/_/husky.sh exists (created by husky init)
  </verify>
  <done>
    Husky pre-commit hook configured to run our validation script.
  </done>
</task>

<task type="auto">
  <name>Test pre-commit hook and verify bypass mechanism</name>
  <files>.husky/pre-commit, scripts/pre-commit.js</files>
  <action>
    Test the pre-commit hook:

    1. Create a test file to trigger a commit:
       echo "// test" > test-pre-commit.ts

    2. Try to commit (should run pre-commit checks):
       git add test-pre-commit.ts
       git commit -m "test: verify pre-commit hook"

    Expected: Pre-commit script runs, builds successfully, starts preview, checks for issues, allows commit.

    3. Test bypass mechanism:
       git commit --no-verify -m "test: bypass pre-commit"

    Expected: Commit succeeds without running pre-commit checks.

    4. Test environment variable bypass:
       PRE_COMMIT_CHECKS_ENABLED=false git commit -m "test: env var bypass"

    Expected: Commit succeeds without running pre-commit checks.

    5. Clean up test commit and file:
       git reset HEAD~1
       rm test-pre-commit.ts

    6. Verify bypass instructions are documented in pre-commit.js error message
  </action>
  <verify>
    - Normal commit triggers pre-commit hook
    - Build runs successfully during pre-commit
    - Preview server starts and stops cleanly
    - --no-verify bypass works
    - PRE_COMMIT_CHECKS_ENABLED=false bypass works
    - Test file cleaned up
  </verify>
  <done>
    Pre-commit hook is functional and bypass mechanisms are tested.
  </done>
</task>

</tasks>

<verification>
Overall verification of pre-commit testing workflow:

1. Husky is installed and initialized in package.json
2. .husky/pre-commit hook calls scripts/pre-commit.js
3. Pre-commit script runs: npm run build
4. Pre-commit script starts preview server
5. Pre-commit script checks for hydration errors
6. Pre-commit script cleans up preview server
7. Bypass with --no-verify works
8. Bypass with PRE_COMMIT_CHECKS_ENABLED=false works

Run: git add . && git commit -m "test: trigger pre-commit" (then reset)
Then: git commit --no-verify -m "test: bypass"
</verification>

<success_criteria>
1. All commits trigger build + preview testing via pre-commit hook
2. Hydration errors fail the commit (zero tolerance per context decision)
3. Pre-commit hook can be bypassed with --no-verify
4. Pre-commit hook can be disabled with environment variable
5. Husky hooks are committed to repository
</success_criteria>

<output>
After completion, create `.planning/phases/05-qa-&-pwa-foundation**---build-testing-infrastructure-and-pwa-features/05-03-SUMMARY.md` with:
- Husky installation summary
- Pre-commit script details
- Testing results
- Bypass mechanisms documented
</output>
