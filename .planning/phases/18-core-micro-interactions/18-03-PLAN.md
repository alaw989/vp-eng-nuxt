---
phase: 18-core-micro-interactions
plan: 03
type: execute
wave: 2
depends_on: ['01']
files_modified:
  - pages/contact.vue
  - composables/useFormValidation.ts
autonomous: true

must_haves:
  truths:
    - "Contact form validates on blur for first interaction"
    - "Contact form validates on input after first error"
    - "Validation errors show inline with visual feedback (red border)"
    - "Validation errors announced via ARIA live regions"
    - "Form validation uses ARIA attributes (aria-invalid, aria-describedby, role=\"alert\")"
  artifacts:
    - path: "pages/contact.vue"
      provides: "Real-time form validation"
      contains: "@blur=\"validate\""
    - path: "composables/useFormValidation.ts"
      provides: "Reusable form validation logic"
      exports: ["useFormValidation"]
  key_links:
    - from: "Form input blur event"
      to: "Validation function"
      via: "@blur handler calling validate"
      pattern: "@blur=\"validate"
    - from: "Validation error"
      to: "Screen reader announcement"
      via: "ARIA live region with role=\"alert\""
      pattern: "role=\"alert\""
---

<objective>
Implement real-time form validation with visual feedback and ARIA announcements for the contact form. This implements MICRO-04 (form validation feedback) requirement.

Purpose: Real-time validation provides immediate feedback, reducing form abandonment and improving user experience. Current implementation only validates on submit, frustrating users who fill the entire form before seeing errors.

Output: Contact form validates on blur/change with inline error messages and ARIA live region announcements.
</objective>

<execution_context>
@/Users/austinlaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/austinlaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/18-core-micro-interactions/18-core-micro-interactions-RESEARCH.md
@.planning/phases/17-accessibility-foundation/17-01-SUMMARY.md

# Current state from codebase audit:
- contact.vue: Has validation on submit (lines 406-454)
- ARIA attributes exist: aria-invalid, aria-describedby, role="alert"
- Missing: Real-time validation on blur/change
- Missing: ARIA live region for announcements

# Phase 17 established patterns:
- ARIA attributes for accessibility (aria-invalid, aria-describedby, role="alert")
- Focus management and screen reader support

# Research recommendation:
- Start with hand-rolled validation (like contact.vue) to establish patterns
- Evaluate Yup/Zod if validation complexity grows in future phases
- Validate on blur for first interaction, on input after first error
</context>

<tasks>

<task type="auto">
  <name>Create useFormValidation composable for reusable validation logic</name>
  <files>composables/useFormValidation.ts</files>
  <action>
    Create composables/useFormValidation.ts with real-time validation:

    ```typescript
    // composables/useFormValidation.ts
    export function useFormValidation<T extends Record<string, any>>(
      schema: Record<keyof T, (value: any) => string | null>
    ) {
      const errors = ref<Partial<Record<keyof T, string>>>({})
      const touched = ref<Partial<Record<keyof T, boolean>>>({})

      // Validate a single field
      const validateField = (field: keyof T, value: any): boolean => {
        touched.value[field] = true

        const validator = schema[field]
        if (!validator) return true

        const error = validator(value)
        if (error) {
          errors.value[field] = error
          announceError(field, error)
          return false
        }

        delete errors.value[field]
        return true
      }

      // Validate all fields
      const validateForm = (data: T): boolean => {
        let isValid = true
        for (const field in schema) {
          if (!validateField(field, data[field])) {
            isValid = false
          }
        }
        return isValid
      }

      // Clear all errors
      const clearErrors = () => {
        errors.value = {}
        touched.value = {}
      }

      // ARIA live region announcement for screen readers
      const announceError = (field: keyof T, message: string) => {
        if (process.client) {
          const announcement = document.getElementById('sr-announcements')
          if (announcement) {
            announcement.textContent = `Validation error for ${String(field)}: ${message}`
          }
        }
      }

      return {
        errors,
        touched,
        validateField,
        validateForm,
        clearErrors
      }
    }
    ```

    DO NOT use external validation libraries (Yup, Zod) per research recommendation.
    DO use TypeScript generics for type safety.
  </action>
  <verify>
    1. File `composables/useFormValidation.ts` exists
    2. `grep "export function useFormValidation" composables/useFormValidation.ts` returns the export
    3. `grep "validateField" composables/useFormValidation.ts` returns the field validation function
    4. `npm run dev` starts without TypeScript errors
  </verify>
  <done>
    useFormValidation composable exists with field-level validation and ARIA announcements
  </done>
</task>

<task type="auto">
  <name>Update contact form to use real-time validation</name>
  <files>pages/contact.vue</files>
  <action>
    Update pages/contact.vue to implement real-time validation:

    1. Add ARIA live region to template (before closing </template>):
       ```vue
       <!-- ARIA live region for screen reader announcements -->
       <div id="sr-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>
       ```

    2. Update script setup to use useFormValidation composable:
       ```typescript
       // Import composable
       import { useFormValidation } from '~/composables/useFormValidation'

       // Define validation schema
       const validationSchema = {
         firstName: (value: string) => {
           if (!value.trim()) return 'First name is required'
           if (value.trim().length < 2) return 'First name must be at least 2 characters'
           return null
         },
         lastName: (value: string) => {
           if (!value.trim()) return 'Last name is required'
           if (value.trim().length < 2) return 'Last name must be at least 2 characters'
           return null
         },
         email: (value: string) => {
           if (!value.trim()) return 'Email is required'
           const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
           if (!emailRegex.test(value)) return 'Please enter a valid email address'
           return null
         },
         phone: (value: string) => {
           if (value && !/^\d{10,}$/.test(value.replace(/\D/g, ''))) {
             return 'Please enter a valid phone number'
           }
           return null
         },
         message: (value: string) => {
           if (!value.trim()) return 'Message is required'
           if (value.trim().length < 10) return 'Message must be at least 10 characters'
           return null
         }
       }

       // Use composable
       const { errors, touched, validateField, validateForm, clearErrors } = useFormValidation(validationSchema)

       // Update handleSubmit to use validateForm
       const handleSubmit = async () => {
         if (!validateForm(form)) {
           return
         }
         // Existing submit logic...
       }
       ```

    3. Update input elements to add blur/input handlers:
       ```vue
       <input
         v-model="form.firstName"
         @blur="validateField('firstName', form.firstName)"
         @input="touched.firstName && validateField('firstName', form.firstName)"
         :aria-invalid="errors.firstName ? 'true' : 'false'"
         :aria-describedby="errors.firstName ? 'firstName-error' : undefined"
         :class="errors.firstName ? 'border-red-500' : 'border-neutral-300'"
       />
       ```

    4. Apply the same pattern to lastName, email, phone, and message fields

    5. Remove old validateForm function (no longer needed, composable handles it)

    DO NOT modify existing form layout or styling.
    DO keep existing ARIA attributes (they complement the new validation).
  </action>
  <verify>
    1. `grep "useFormValidation" pages/contact.vue` returns the composable import
    2. `grep "@blur=\"validateField" pages/contact.vue` returns blur handlers on all inputs
    3. `grep "sr-announcements" pages/contact.vue` returns the ARIA live region
    4. `npm run dev` starts without errors
    5. Functional test: Submit empty form, see errors inline. Tab out of field, see error appear.
  </verify>
  <done>
    Contact form validates on blur/change with inline errors and ARIA live region announcements
  </done>
</task>

<task type="auto">
  <name>Test and document real-time validation implementation</name>
  <files>.planning/phases/18-core-micro-interactions/18-03-SUMMARY.md</files>
  <action>
    Create summary document with:

    1. useFormValidation composable implementation
       - Function signature and exports
       - Field-level validation approach
       - ARIA announcement implementation

    2. Contact form updates
       - Blur handlers for first interaction validation
       - Input handlers for re-validation after errors
       - ARIA live region added for screen readers

    3. Validation rules implemented
       - firstName: Required, min 2 characters
       - lastName: Required, min 2 characters
       - email: Required, email format
       - phone: Optional, phone format if provided
       - message: Required, min 10 characters

    4. Testing results
       - Visual feedback: Red borders on error fields
       - Inline error messages: Show below each field
       - ARIA announcements: Screen reader hears errors
       - Touch tracking: Only validate after first interaction

    5. Deviations from plan (if any)

    Include code examples for each validation pattern.
  </action>
  <verify>
    1. File `.planning/phases/18-core-micro-interactions/18-03-SUMMARY.md` exists
    2. Summary contains composable documentation
    3. Summary contains form update documentation
    4. Summary contains validation rules
  </verify>
  <done>
    Real-time validation implementation documented with composable and form updates
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. `npm run dev` starts without errors
2. Visit /contact page
3. Tab through form without entering data: no errors show (not touched yet)
4. Enter data in first field, tab out: validation runs inline
5. Enter invalid data: error shows immediately with red border + inline message
6. Correct error: error clears immediately
7. Submit with errors: form doesn't submit, errors show
8. Screen reader test: ARIA live region announces errors
</verification>

<success_criteria>
1. useFormValidation composable created with field-level validation
2. Contact form validates on blur for first interaction
3. Contact form validates on input after first error
4. Validation errors show inline with visual feedback
5. ARIA live region announces errors to screen readers
6. Form uses ARIA attributes (aria-invalid, aria-describedby, role="alert")
</success_criteria>

<output>
After completion, create `.planning/phases/18-core-micro-interactions/18-03-SUMMARY.md` with:
- useFormValidation composable implementation
- Contact form real-time validation updates
- Validation rules documentation
- Testing results (visual, functional, accessibility)
- Deviations from plan (if any)
</output>
