---
phase: 18-core-micro-interactions
plan: 04
type: execute
wave: 2
depends_on: ['01']
files_modified:
  - pages/projects/index.vue
  - pages/services/index.vue
  - components/LoadingSkeleton.vue
  - components/ProjectCardSkeleton.vue
  - components/ServiceCardSkeleton.vue
  - components/TeamMemberSkeleton.vue
autonomous: true

must_haves:
  truths:
    - "Projects index shows skeleton screens while loading"
    - "Services index shows skeleton screens while loading"
    - "Skeleton screens match content layout (no CLS when content loads)"
    - "Skeleton screens are marked with aria-hidden=\"true\""
    - "Existing skeleton components are used consistently"
  artifacts:
    - path: "pages/projects/index.vue"
      provides: "Projects listing with skeleton loading state"
      contains: "ProjectCardSkeleton"
    - path: "pages/services/index.vue"
      provides: "Services listing with skeleton loading state"
      contains: "ServiceCardSkeleton"
  key_links:
    - from: "useFetch pending state"
      to: "Skeleton screen display"
      via: "v-if=\"pending\" conditional rendering"
      pattern: "v-if=\"pending\""
    - from: "Skeleton component"
      to: "Content structure match"
      via: "Identical DOM structure and spacing"
      pattern: "ProjectCardSkeleton|ServiceCardSkeleton"
---

<objective>
Implement skeleton loading screens for all async content to provide visual feedback during data fetching. This implements MICRO-05 (loading states) requirement.

Purpose: Skeleton screens improve perceived performance by showing content placeholders during loading. Existing skeleton components exist but aren't consistently used across the site.

Output: All async content (projects index, services index) shows skeleton screens during loading with matching layout to prevent CLS.
</objective>

<execution_context>
@/Users/austinlaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/austinlaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/18-core-micro-interactions/18-core-micro-interactions-RESEARCH.md

# Current state from codebase audit:
- 6 skeleton components exist: LoadingSkeleton.vue, ProjectCardSkeleton.vue, ServiceCardSkeleton.vue, TeamMemberSkeleton.vue, ProjectDetailSkeleton.vue, SearchResultSkeleton.vue
- Skeleton pattern: `animate-pulse` with `bg-neutral-200` placeholders
- Missing: Consistent usage across all async content
- pages/projects/index.vue: Unknown skeleton usage
- pages/services/index.vue: Unknown skeleton usage

# Existing skeleton components:
- LoadingSkeleton.vue: Generic skeleton (18 lines)
- ProjectCardSkeleton.vue: Project card placeholder (32 lines)
- ServiceCardSkeleton.vue: Service card placeholder
- TeamMemberSkeleton.vue: Team member placeholder

# Research recommendation:
- Keep specific skeletons (ProjectCardSkeleton, etc.) for precise layout matching
- Use skeletons for all async content to prevent CLS
- Mark skeletons with aria-hidden="true" to prevent screen reader confusion
</context>

<tasks>

<task type="auto">
  <name>Add skeleton loading state to projects index page</name>
  <files>pages/projects/index.vue</files>
  <action>
    Update pages/projects/index.vue to show skeleton screens during loading:

    1. Check current data fetching implementation:
       - Look for `useFetch`, `useAsyncData`, or `useLazyFetch`
       - Identify `pending` state from data fetching composable

    2. Add skeleton loading state before project cards grid:
       ```vue
       <!-- Loading State -->
       <div v-if="pending" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8" aria-hidden="true">
         <ProjectCardSkeleton v-for="i in 6" :key="`skeleton-${i}`" />
       </div>

       <!-- Projects Grid -->
       <div v-else-if="projects && projects.length > 0" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
         <ProjectCard
           v-for="project in projects"
           :key="project.id"
           v-bind="project"
         />
       </div>

       <!-- Empty State -->
       <div v-else class="text-center py-12">
         <p class="text-neutral-600">No projects found matching your criteria.</p>
       </div>
       ```

    3. Ensure `pending` state is properly destructured from data fetching:
       ```typescript
       const { data: projects, pending } = await useLazyFetch('/api/projects', {
         // existing options
       })
       ```

    4. If using `useFetch` or `useAsyncData`, switch to `useLazyFetch` for better UX:
       - `useLazyFetch` doesn't block route navigation
       - Shows skeleton immediately instead of blank page

    DO NOT modify existing project card rendering logic.
    DO keep existing filter/sort functionality unchanged.
  </action>
  <verify>
    1. `grep "ProjectCardSkeleton" pages/projects/index.vue` returns skeleton usage
    2. `grep "v-if=\"pending\"" pages/projects/index.vue` returns pending state check
    3. `grep "aria-hidden=\"true\"" pages/projects/index.vue` returns skeleton accessibility attribute
    4. `npm run dev` starts without errors
    5. Visual test: Visit /projects, see skeleton briefly before content loads
  </verify>
  <done>
    Projects index shows skeleton screens during loading with matching layout
  </done>
</task>

<task type="auto">
  <name>Add skeleton loading state to services index page</name>
  <files>pages/services/index.vue</files>
  <action>
    Update pages/services/index.vue to show skeleton screens during loading:

    1. Check current data fetching implementation:
       - Look for `useFetch`, `useAsyncData`, or `useLazyFetch`
       - Identify `pending` state from data fetching composable

    2. Add skeleton loading state before service cards grid:
       ```vue
       <!-- Loading State -->
       <div v-if="pending" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8" aria-hidden="true">
         <ServiceCardSkeleton v-for="i in 6" :key="`skeleton-${i}`" />
       </div>

       <!-- Services Grid -->
       <div v-else-if="services && services.length > 0" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
         <ServiceCard
           v-for="service in services"
           :key="service.id"
           v-bind="service"
         />
       </div>

       <!-- Empty State -->
       <div v-else class="text-center py-12">
         <p class="text-neutral-600">No services found.</p>
       </div>
       ```

    3. Ensure `pending` state is properly destructured:
       ```typescript
       const { data: services, pending } = await useLazyFetch('/api/services', {
         // existing options
       })
       ```

    4. If using `useFetch` or `useAsyncData`, switch to `useLazyFetch` for better UX

    DO NOT modify existing service card rendering logic.
    DO keep existing functionality unchanged.
  </action>
  <verify>
    1. `grep "ServiceCardSkeleton" pages/services/index.vue` returns skeleton usage
    2. `grep "v-if=\"pending\"" pages/services/index.vue` returns pending state check
    3. `grep "aria-hidden=\"true\"" pages/services/index.vue` returns skeleton accessibility attribute
    4. `npm run dev` starts without errors
    5. Visual test: Visit /services, see skeleton briefly before content loads
  </verify>
  <done>
    Services index shows skeleton screens during loading with matching layout
  </done>
</task>

<task type="auto">
  <name>Verify skeleton components match content layout</name>
  <files>components/ProjectCardSkeleton.vue, components/ServiceCardSkeleton.vue, components/TeamMemberSkeleton.vue</files>
  <action>
    1. Review ProjectCardSkeleton.vue:
       - Compare DOM structure to ProjectCard.vue
       - Verify matching aspect ratios (image container)
       - Verify matching padding, margins, border-radius
       - Verify matching grid layout (title, description, meta)

    2. Review ServiceCardSkeleton.vue:
       - Compare DOM structure to ServiceCard.vue
       - Verify matching icon placeholder size
       - Verify matching text placeholder heights

    3. Review TeamMemberSkeleton.vue:
       - Compare DOM structure to TeamMember.vue
       - Verify matching aspect ratios (photo container)
       - Verify matching contact link layout

    If skeleton layout doesn't match content:
    - Update skeleton to use exact same classes as content component
    - Match padding, margins, rounded corners, shadows
    - Match text line heights and clamping

    DO NOT add skeletons to components that don't need them (e.g., static content).
  </action>
  <verify>
    1. `grep "aspect-\\[4/3\\]" components/ProjectCardSkeleton.vue components/ProjectCard.vue` both return (matching aspect ratio)
    2. `grep "rounded-xl" components/ProjectCardSkeleton.vue components/ProjectCard.vue` both return (matching border radius)
    3. `grep "p-6\\|p-8" components/ServiceCardSkeleton.vue components/ServiceCard.vue` both return (matching padding)
    4. Visual test: Load pages, observe no layout shift when content replaces skeleton
  </verify>
  <done>
    All skeleton components match content layout with identical spacing, aspect ratios, and structure
  </done>
</task>

<task type="auto">
  <name>Document skeleton loading state implementation</name>
  <files>.planning/phases/18-core-micro-interactions/18-04-SUMMARY.md</files>
  <action>
    Create summary document with:

    1. Skeleton components inventory
       - List all existing skeleton components
       - Document usage location for each skeleton

    2. Pages updated with skeleton loading
       - pages/projects/index.vue: ProjectCardSkeleton usage
       - pages/services/index.vue: ServiceCardSkeleton usage
       - Pending state implementation (useLazyFetch)

    3. Layout verification results
       - ProjectCardSkeleton matches ProjectCard layout
       - ServiceCardSkeleton matches ServiceCard layout
       - TeamMemberSkeleton matches TeamMember layout
       - CLS prevention confirmed

    4. Accessibility implementation
       - All skeletons marked with aria-hidden="true"
       - Screen readers don't announce placeholder content

    5. Performance considerations
       - useLazyFetch for non-blocking data fetching
       - Skeleton displays immediately on navigation
       - No blank page states during loading

    6. Deviations from plan (if any)

    Include code examples for skeleton usage patterns.
  </action>
  <verify>
    1. File `.planning/phases/18-core-micro-interactions/18-04-SUMMARY.md` exists
    2. Summary contains skeleton components inventory
    3. Summary contains pages updated section
    4. Summary contains layout verification results
  </verify>
  <done>
    Skeleton loading state implementation documented with components inventory and layout verification
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. `npm run dev` starts without errors
2. Visit /projects: see skeleton screens briefly, then content loads without layout shift
3. Visit /services: see skeleton screens briefly, then content loads without layout shift
4. Skeleton layouts match content layouts (same spacing, aspect ratios)
5. Skeletons have aria-hidden="true" attribute
6. No blank page states during loading (skeletons appear immediately)
7. CLS (Cumulative Layout Shift) is minimal when content loads
</verification>

<success_criteria>
1. Projects index shows ProjectCardSkeleton during loading
2. Services index shows ServiceCardSkeleton during loading
3. Skeleton screens match content layout (no CLS)
4. Skeletons marked with aria-hidden="true"
5. useLazyFetch used for non-blocking data fetching
6. All existing skeleton components verified for layout matching
</success_criteria>

<output>
After completion, create `.planning/phases/18-core-micro-interactions/18-04-SUMMARY.md` with:
- Skeleton components inventory
- Pages updated with skeleton loading
- Layout verification results
- Accessibility implementation (aria-hidden)
- Performance considerations
- Deviations from plan (if any)
</output>
